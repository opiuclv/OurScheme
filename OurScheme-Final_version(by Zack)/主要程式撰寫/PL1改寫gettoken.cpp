// 10527124
// 資訊三甲
// 邱正皓
// 程式語言 PL 第一次程式作業 OurScheme


/*
	現在要改的是讓gettoken回傳token跟type，目前是想丟到vector裡面  
	terminal (token) :
	  LEFT-PAREN       // '('
	  RIGHT-PAREN      // ')'
	  INT              // e.g., '123', '+123', '-123'
	  STRING           // "string's (example)." (strings do not extend across lines)
	  DOT              // '.'
	  FLOAT            // '123.567', '123.', '.567', '+123.4', '-.123'
	  NIL              // 'nil' or '#f', but not 'NIL' nor 'nIL'
	  T                // 't' or '#t', but not 'T' nor '#T'
	  QUOTE            // '
	  SYMBOL           // a consecutive sequence of printable characters that are
	                   // not numbers, strings, #t or nil, and do not contain 
	                   // '(', ')', single-quote, double-quote, semi-colon and 
	                   // white-spaces ; 
	                   // Symbols are case-sensitive 
	                   // (i.e., uppercase and lowercase are different);
*/


# include <stdio.h>
# include <cstdlib>
# include <string>
# include <vector>
# include <iostream>
# include <sstream>
# include<string.h>
 
using namespace std ;

typedef enum {INT, FLOAT, SYMBOL, LEFT_PAREN, RIGHT_PAREN, NIL, STRING, DOT, T, QUOTE} token_enum;

struct token {
	token_enum token_type ;// 儲存gettoken的資料型別
	char data[50] ;// 儲存gettoken的內容
}  ;

vector<struct token> gToken;
token token_info ;
int gNum = 0 ;
bool gIn_LP = false ; // 判斷是不是在LP裡面，如果是的話要換行 

// **********************************Binary tree 宣告**************************************
struct Tree_node {
	token tree_token ; 
	Tree_node *left;
	Tree_node *right;
} ;


// **********************************Binary tree 宣告**************************************

/*
void Atom() {
	
	
} // Atom


void read_form_token() {
	char console[100] = "" ;
	bool Last_ch_is_LP = false ;
	int count = 0 ;

	if ( gToken.size() == 0 ) {
		printf("SyntaxError('unexpected EOF')") ; // 完全沒有輸入資料
		return ; 
	} // if
	
    if ( gToken[0].data == "(" ){
        while (gToken[0].data != ")") {
        	strcat(console, gToken[0].data );
        	// read_from_tokens(gToken[0].data);
		}

        return console;
	}
	
    else if ( gToken[0].data == ")") {
    	printf("SyntaxError('unexpected')") ;
	}    
    else {
    	return Atom(token) ;
	}
}

void Parse () {
	read_form_token() ;
} // Parse
*/
// ********************************處理Token************************************************ 

void PrintTree( Tree_node *ptr ) {
	
	printf("EE") ;
	
	if(ptr->left != NULL) { // 走訪
		printf("%s ", ptr->tree_token.data);
		PrintTree(ptr->left);
	} // if
	else if(ptr->right != NULL) { // 走訪
		printf("%s ", ptr->tree_token.data);
		PrintTree(ptr->right);
	} // else if
	else return ;
	
	printf("HH") ;

} // PrintTree()


void BuildTree( Tree_node *ptr, int num ) { // 建樹 必須符合Syntax 輸出 

	//	遞迴每 return一次就會回去一層 

	Tree_node *exp = new Tree_node ; // 建立新的node
	if ( exp == NULL) {	
		exp = ptr ; // 可以把 exp想成 root 指向樹根，然後是ptr在跑 
	} // if
	
	if ( gToken.size() == 0 ) {
		printf("SyntaxError('unexpected EOF')") ; // 完全沒有輸入資料
		return ; 
	} // if
	
	if ( num == gToken.size()) { //終止條件 
		//if ( exp != NULL ) {
		//	PrintTree( exp ) ;
		//	exp = NULL ;
		//} // if
		return ;
	} // if

	if ( ptr->right == NULL && gToken[num].data != "(" && gToken[num].data != ")" ) {
		strcpy(ptr ->tree_token.data, gToken[num].data); // 存值進data，注意字串要用strcpy
		if ( gToken[num+1].data != "(" && gToken[num+1].data != ")" ){ // ()要另外處理，不能直接往右 
			BuildTree(ptr->right, num + 1);
		} // if
	} // if
		
	// 注意!! 遇到右括號，應該是要一路遞迴到上一次右腳是空的情況
	 
	if ( ptr->left == NULL && gToken[num].data == "(" ) {
		// 如果是左括號 token往左邊存 
		BuildTree(ptr->left, num + 1);
	} // if
	
	if ( gToken[num].data == ")" ) {
		// 如果是右括號 token往右邊存 
		if ( ptr->right != NULL ) {
			return ;
		} // if
		else BuildTree(ptr->right, num + 1);
	} // if

	return ;
} // BuildTree()

void Welcome_and_read() {

	cout << "Welcome to OurScheme!\n" << "\n";
	string text = "";
	char ch ;
	char temp ;
	temp = scanf( "%c", &ch ); // 把數字讀掉
	temp = scanf( "%c", &ch );
	if ( temp == EOF ) return ;
} // Welcome_and_read()

void GetToken () { // GetToken 先全部照單全收，要印的時候用C語言把歸類成 float的token，用%3f的函數去印 

	char text[1000] = "" ; // 用來暫存token 
	char ch[1] ; // 用來讀檔 
	char temp_ch[1] ; // 輔助讀檔 
	scanf( "%c", &ch ); // 一次讀一個字元 
	char temp ;
	int count_decimal = 0 ; // 用來處理 float後面的小數 
	int count_decimal2 = 3 ;
	int num = 0 ;
	bool have_print = false ; // 單獨拉出來處理的 token ex.string , command 
	bool for_break = false ; // 給 PAL用的 break()
	bool is_float = true ; // 用來判斷是不是 float (關係到DOT的使用)
	bool only_dot = false ; 
	string space = "";

	while ( temp != EOF ) { // 讀到結束

		while ( temp != EOF && ch[0] != '\n' ) { // 讀到換行 \n
			// ********************************************************************
			if ( ch[0] == '+' ) { // 遇到 + 就讀掉
				scanf( "%c", &ch );
				if ( ch[0] == '-' ) { // 如果是+-開頭直接全部讀完換下一行
					strcat( text , "+-" ) ;
					scanf( "%c", &ch );
					while ( ch[0] != EOF && ch[0] != '\n' ) {
						strcat( text , ch ) ;
						scanf( "%c", &ch );
					} // while

					for_break = true ;
				} // if
			} // if
			// ********************************************************************
			if ( ch[0] == '.' && !for_break ) { // 遇到點
				scanf( "%c", &ch );
				if ( ch[0] < 48 || ch[0] > 57 ) {
					if ( ch[0] != '+' && ch[0] != '-' && ch[0] != '.' && ch[0] != '\n' ) {
						is_float = false ;
						only_dot = true ;
					} // if
				} // if

				if ( ch[0] == '\n' ) { // 點在數字最後面
					if ( is_float && !only_dot ) strcat( text , ".000" ) ;
					else strcat( text , "." ) ;
					for_break = true ;
				} // if
				else if ( ch[0] == ' ' ) {
					scanf( "%c", &ch );
					strcat( text , ". " ) ;
					while ( ch[0] != EOF && ch[0] != '\n' ) {
						strcat( text , ch ) ;
						scanf( "%c", &ch );
					} // while

					for_break = true ;
				} // else if
				else if ( text == "" || text == "-" ) { // 點在數字最前面，且點後最少有一個數字
					strcat( text , "0." ) ;
					while ( ch[0] != '\n' ) { // 反正這兩個while就是在算小數位
						if ( count_decimal < 2 ) strcat( text , ch ) ; // 小數後前兩位一定印
						if ( count_decimal == 2 ) { // 第三位先存起來等待判斷要不要加一
							temp_ch[0] = ch[0] ;
						} // if

						if ( count_decimal == 3 ) { // 第四位以後的處理
							if ( ch[0] >= 53 ) {
								temp_ch[0] = temp_ch[0] + 1 ;
								strcat( text , temp_ch ) ; // 這裡在處理的是4捨5入 
							} // if
							else if ( ch[0] <= 52 ) strcat( text , temp_ch ) ;
						} // if

						scanf( "%c", &ch );
						count_decimal ++ ;
					} // while

					if ( ch[0] == '\n' && count_decimal == 3 ) strcat( text , temp_ch ) ; // 補足小數後剛好有三位的浮點數
					while ( count_decimal2 > count_decimal && is_float ) { // 不夠位數就補0
						strcat( text , "0" ) ;
						count_decimal2 -- ;
					} // while

					count_decimal = 0 ;
					count_decimal2 = 3 ;
					num = 0 ;
					for_break = true ;
				} // else if
				else { // 點在中間
					strcat( text , "." );
					while ( ch[0] != '\n' ) { // 反正這兩個while就是在算小數位
						if ( count_decimal < 2 ) strcat( text , ch ) ; // 小數後前兩位一定印
						if ( count_decimal == 2 ) { // 第三位先存起來等待判斷要不要加一
							temp_ch[0] = ch[0] ;
						} // if

						if ( count_decimal == 3 ) { // 第四位以後的處理
							if ( ch[0] >= 53 ) {
								temp_ch[0] = temp_ch[0] + 1 ;
								strcat( text , temp_ch ) ; // 這裡再處理的是4捨5入 
							} // if
							else if ( ch[0] <= 52 ) strcat( text , temp_ch ) ;
						} // if

						scanf( "%c", &ch );
						count_decimal ++ ;
					} // while

					if ( ch[0] == '\n' && count_decimal == 3 ) strcat( text , temp_ch ) ; // 補足小數後剛好有三位的浮點數
					while ( count_decimal2 > count_decimal && is_float ) { // 不夠位數就補0
						strcat( text , "0" ) ;
						count_decimal2 -- ;
					} // while

					count_decimal = 0 ;
					count_decimal2 = 3 ;
					num = 0 ;
					for_break = true ;
				} // else
			} // if

			// ********************************************************************
			
			if ( ch[0] == '(' && !for_break ) {
				strcat( text , ch ) ;
				strcpy( token_info.data, ch ) ; // 存取token資訊 
				token_info.token_type = LEFT_PAREN ;
				gToken.push_back(token_info) ;
				scanf( "%c", &ch );
			} // if
			
			if ( ch[0] == ')' && !for_break ) {
				strcat( text , ch ) ;
				strcpy( token_info.data, ch ) ; // 存取token資訊 
				token_info.token_type = RIGHT_PAREN ;
				gToken.push_back(token_info) ;
				scanf( "%c", &ch );
			} // if

			// ********************************************************************

			if ( ch[0] == ';' && !for_break ) {
				if ( text == "" ) { // 表示整行是由 ; 開頭 command 
					while ( ch[0] != '\n' ) {
						scanf( "%c", &ch );
					} // while
					for_break = true ;
					have_print = true ; // 為了整行都不要印
				} // if
			} // if

			// ********************************************************************

			if ( ch[0] == 't' && text == "" && !for_break ) { // text == "" 是因為只有t單獨才能進
				scanf( "%c", &ch );
				if ( ch[0] == '\n' ) {
					strcpy( text , "#t" ) ; // 真的是strcpy沒打錯 
					for_break = true ;
				} // if
				else {
					strcat( text , "t" ) ;
				} // else
			} // if

			// ********************************************************************
			if ( ch[0] == '#' && !for_break ) {
				scanf( "%c", &ch );
				if ( ch[0] == 't' ) {
					scanf( "%c", &ch );
					if ( ch[0] == '\n' ) {
						strcat( text , "#t" ) ;
						for_break = true ;
					} // if
					else {
						while( ch[0] != '\n' ) { // 讀到換行讀乾淨 後面才不會錯
							scanf( "%c", &ch );
						} // while
						strcat( text , "#tt" ) ;
						for_break = true ;
					} // else
				} // if
				else {
					strcat( text , "#" ) ;
					strcat( text , ch ) ; // 原本要做的
					scanf( "%c", &ch );
					if ( ch[0] == '\n' ) { // 如果要做特殊情況 直接改成nil
						strcat( text , "nil" ) ;
						for_break = true ;
					} // if
				} // else
			} // if
			// ********************************************************************
			
			if ( ch[0] > 47 && ch[0] < 58 ) { // 數字開頭的處理
				strcpy(text, "") ;
				strcat( text , ch ) ; 
				scanf( "%c", &ch );
				while (ch[0] != ' ' && ch[0] != '\n' && ch[0] > 47 && ch[0] < 58 || ch[0] == '.' ){
					strcat( text , ch ) ;
					scanf( "%c", &ch );
					if( ch[0] == '.' ) is_float = true;
				} // while
				
				if ( ch[0] != ' ' && ch[0] != '(' && ch[0] != ')' ) { // 後面不是空白 代表他不是純數字 
					strcat( text , ch ) ;
					scanf( "%c", &ch );
					strcpy( token_info.data, text ) ; // 存取token資訊 
					token_info.token_type = SYMBOL ;
					gToken.push_back(token_info) ;
					have_print = true ; // 已經存過了 
				} // if
				else {
					strcpy( token_info.data, text ) ; // 存取token資訊 
					if ( is_float ) token_info.token_type = FLOAT ;
					else token_info.token_type = INT ;
					gToken.push_back(token_info) ;
					have_print = true ; // 已經存過了 
				} // else
				cout << "> " << text << "\n" << "\n" ;
				for_break = true ;
			} // if
			
			// ********************************************************************

			if ( !for_break ) strcat( text , ch ) ;
			if ( ch[0] < 48 || ch[0] > 57 ) { // 要檢查2遍才完整 非數字 
				if ( ch[0] != '+' && ch[0] != '-' && ch[0] != '.' && ch[0] != '\n' ) {
					is_float = false ;
					only_dot = true ;
				} // if
			} // if
			temp_ch[0] = ch[0] ; // 暫存前一個ch[0]
			if ( !for_break ) scanf( "%c", &ch );
			if ( ch[0] < 48 || ch[0] > 57 ) { // 要檢查2遍才完整
				if ( ch[0] != '+' && ch[0] != '-' && ch[0] != '.' && ch[0] != '\n' ) {
					is_float = false ;
					only_dot = true ;
				} // if
			} // if

			bool is_string = false ;
			// ********************************************************************
			if ( temp_ch[0] == '\"' &&  ch[0] == ' ' ) { // 為了去除最後加了很多空白的情況
				int num = 1 ;
				scanf( "%c", &ch );
				while ( ch[0] == ' ' ) {
					scanf( "%c", &ch );
					num ++ ;
				} // while
				if ( ch[0] != '\n' ) {
					while ( num != 0 ) {
						strcat( text , " " ) ;
						num -- ;
					} // while
				} // if
			} // if

			// ********************************************************************
			if ( ch[0] == '\'' && !for_break ) { // 遇到'\'' ===> QUOTE
				is_string = true ;
				strcat( text , ch ) ;
				scanf( "%c", &ch );
			} // if
			// ********************************************************************
			if ( ch[0] == '\"' ) { // string需要另外處理 
				strcat( text , ch ) ;
				scanf( "%c", &ch );
				while ( ch[0] != EOF && ch[0] != '\n' && ch[0] != '\"' ) {
					if ( ch[0] == '\\' && !for_break ) { // 讀到\除非是換行字元不然先無條件捨棄一個 
						scanf( "%c", &ch );
						if ( ch[0] == 'n' ) { // 讀到\n但不是換行字元
							cout << "> " << text << "\n" ; // 印出換行字元以前的值
							strcat( text , "" ) ;
							scanf( "%c", &ch );
							while ( ch[0] != EOF && ch[0] != '\n' && ch[0] != ' ' ) {
								strcat( text , ch ) ;
								scanf( "%c", &ch );
							} // while
							strcpy( token_info.data, text ) ; // 存取token資訊 
							token_info.token_type = STRING ;
							gToken.push_back(token_info) ;
							cout << text << "\n" << "\n"; // 印出換行後的值
							have_print = true ; // 已經處理過了後面不用再印一次
						} // if
						else if ( ch[0] != '\\' && ch[0] != '"' ) strcat( text , "\\" ) ; // 判斷只有一個\的情況
						else if ( ch[0] == '\\' ) {  // 判斷兩個\以上的情況
							while ( ch[0] == '\\' && ch[0] != ' ' ) {
								scanf( "%c", &ch );
							} // while
							strcat( text , "\\" );
						}
					} // if
					else {
						strcat( text , ch ) ;
						scanf( "%c", &ch );
					}
				} // while
				
		   } // if
		   
		} // while
		if ( text == "(exit)" ) {
			cout << "> " << "\n" ;
			return ;
		} // if
		if ( !have_print ) { // 上面沒有存進去 所以在這存 
			strcpy( token_info.data, text ) ; // 存取token資訊 
			token_info.token_type = STRING ;
			gToken.push_back(token_info) ;
			cout << "> " << text << "\n" << "\n" ;
		} // if 
		
		// *************************************************處理parse tree ************************************* 
		Tree_node *root = new Tree_node;
		root ->left= NULL;
		root ->right= NULL;
		strcpy(root ->tree_token.data, gToken[0].data ); // 初始化 tree , 並放入第一筆 data 
		// BuildTree(root, 0);
		// *************************************************處理parse tree ************************************* 
		int k = 0 ;
		while ( k < gToken.size()) {
			cout << gToken.size() << "JJ" << gToken[k].data << "\n" ;
			k++ ;
		} //while
		gToken.clear() ;
		have_print = false ;
		for_break = false ;
		is_float = true ;
		only_dot = false ;
		strcpy( text , "" ) ;
		temp = scanf( "%c", &ch );

	} // while
	if ( temp == EOF ) {
		cout << "> " << "ERROR (no more input) : END-OF-FILE encountered" << "\n" ;
		return ;
	} // if
}

int main() {
	Welcome_and_read() ;
	GetToken();
	
	if( gToken.size() == 0 ) {
		printf("you are without input") ;
		return 0 ;
	}
	
} // main()



